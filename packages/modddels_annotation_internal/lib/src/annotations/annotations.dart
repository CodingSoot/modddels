import 'package:modddels_annotation_internal/src/annotations/shared_props.dart';
import 'package:modddels_annotation_internal/src/annotations/validation.dart';
import 'package:modddels_annotation_internal/src/modddels/failures.dart';
import 'package:modddels_annotation_internal/src/modddels/modddel_interfaces.dart';

/// Flags a class to be processed by the Modddels Generator.
///
class Modddel {
  const Modddel({
    required this.validationSteps,
    this.sharedProps = const [],
    this.generateTestClasses = false,
    this.maxTestInfoLength = 200,
  });

  static const int noMaxLength = -1;

  final List<ValidationStep> validationSteps;

  final List<SharedProp> sharedProps;

  /// Whether to generate unit-testing classes for this modddel / union of
  /// modddels.
  ///
  /// Defaults to `true`.
  ///
  final bool generateTestClasses;

  /// The tests generated by the methods of the Tester have a description that
  /// can contain the String representation of objects such as ModddelParams, a
  /// failure, etc...
  ///
  /// If [maxTestInfoLength] is set to a number greater than 0, each of those
  /// strings will be ellipsized whenever their length exceeds that number.
  ///
  /// If it is set to [Modddel.noMaxLength], those strings will be fully
  /// included in the test's description.
  ///
  /// Defaults to `200`.
  ///
  final int maxTestInfoLength;
}

class ValidParamAnnotation {
  const ValidParamAnnotation();
}

/// This annotation can only be used inside a SimpleEntity, in front of a member
///  parameter.
///
/// Use this annotation :
/// - (1) When the parameter is a [ValidModddel]
/// - (2) When the parameter isn't a modddel and should be considered as being
///   valid
///
/// Example :
///
/// ```dart
/// factory Person({
///     required FullName name,
///     /// (1)
///     @validParam required ValidAge age,
///     /// (2) More frequent usecase
///     @validParam required bool isMarried,
///   }) { ...
/// ```
///
const validParam = ValidParamAnnotation();

class InvalidParamAnnotation {
  const InvalidParamAnnotation();
}

/// This annotation can only be used inside a SimpleEntity, in front of a
/// **nullable** member parameter.
///
/// Use this annotation when the parameter is an [InvalidModddel] that should
/// always be considered as invalid, unless it's null.
///
/// Example :
///
/// ```dart
/// factory FreeArticle({
///     required Description description,
///     @invalidParam required InvalidPrice? price,
///   }) { ...
/// ```
///
const invalidParam = InvalidParamAnnotation();

class WithGetterAnnotation {
  const WithGetterAnnotation();
}

/// This annotation can be used inside any modddel / union of modddels, in front
/// of a member parameter.
///
/// Use this annotation if you want to have a direct getter for the member
/// parameter.
///
/// For Example :
///
/// ```dart
/// factory Book({
///   @withGetter required String id,
///   required String title,
/// })
/// ```
///
/// Now you can directly access the `id` field from a `Book` instance :
///
/// ```dart
/// // Allowed.
/// final id = book.id;
///
/// // Error.
/// final title = book.title;
/// ```
///
const withGetter = WithGetterAnnotation();

class ValidWithGetterAnnotation {
  const ValidWithGetterAnnotation();
}

/// Same as specifying both the [validParam] and [withGetter] annotations.
///
/// Example :
///
/// ```dart
/// factory Person({
///     required FullName name,
///     @validWithGetter required bool isMarried,
///   }) { ...
/// ```
///
const validWithGetter = ValidWithGetterAnnotation();

class InvalidWithGetterAnnotation {
  const InvalidWithGetterAnnotation();
}

/// Same as specifying both the [invalidParam] and [withGetter] annotations.
///
/// Example :
///
/// ```dart
/// factory FreeArticle({
///     required Description description,
///     @invalidWithGetter required InvalidPrice? price,
///   }) { ...
/// ```
///
const invalidWithGetter = InvalidWithGetterAnnotation();

/// This annotation can be used inside any modddel / union of modddels, in front
/// of a **nullable** member parameter.
///
/// Use this annotation if the parameter should cause a validation to fail when
/// it's null. You provide two arguments : The name of that validation
/// [validationName], and the [failure] it would fail with.
///
/// Example :
///
/// ```dart
/// factory Name({
///   @NullFailure('length', NameSizeFailure.empty()) required String? value,
/// }) {...}
/// ```
///
/// In this example, if `value` is null, then the "length" validation will fail,
/// with as a failure `NameSizeFailure.empty()`.
///
/// > **NB :** The [failure] should only include references to top-level
/// > elements.
///
class NullFailure {
  const NullFailure(this.validationName, this.failure, {this.maskNb});

  final String validationName;

  final Failure failure;

  /// This should only be provided with Iterable2Entities. It is used to specify
  /// which modddel type the annotation is refering to.
  ///
  /// Example :
  ///
  ///  ```dart
  ///  /// MapEntity example.
  ///  ///
  ///  /// The TypeTemplate of the MapEntity is Map<#1,#2>
  ///
  ///  factory BookMap({
  ///    // This nullfailure refers to the '#2' mask, which in this case matches
  ///    //'Book?'
  ///    @NullFailure('bibliography', BookMapBibliographyFailure.hasNoBook(), maskNb: 2)
  ///        required Map<Author, Book?> booksByAuthors,
  ///  })
  ///  ```
  ///
  final int? maskNb;
}

class DependencyParamAnnotation {
  const DependencyParamAnnotation();
}

/// This annotation can be used inside any modddel / union of modddels, in front
/// of a factory parameter.
///
/// Use this annotation when you want to mark a parameter as a dependency
/// parameter.
///
const dependencyParam = DependencyParamAnnotation();

/// An IterableEntity or Iterable2Entity have only **one member parameter**,
/// which is the collection of modddels. For example, a 'BookList' ListEntity
/// will have one member parameter `List<Book> books`.
///
/// The TypeTemplate is the template that the type of the member parameter
/// should match. Every IterableEntity/Iterable2Entity kind has a type template.
///
/// For example, the type template of a MapEntity (which is an Iterable2Entity)
/// is 'Map<#1,#2>' :
///
/// - **`#1`** and **`#2`** are **masks**. `#1` matches the first modddel type
///   of the MapEntity, and `#2` matches the second modddel type.
/// - So this type template would match for example : `Map<Username, Password>`.
///
/// Let's take another example : the type template of a MappedValuesEntity
/// (which is an IterableEntity) is `Map<*,#1>` :
///
/// - The **`*`** is a **wildcard** : it matches any type argument.
/// - The **`#1`** is a **mask** : it matches the modddel type of the
///   MappedValuesEntity.
/// - So this type template would match for example : `Map<int, Person>` and
///   `Map<String, Person>`.
///
/// The [TypeTemplate] annotation is used to define the TypeTemplate of an
/// IterableEntity or Iterable2Entity.
///
class TypeTemplate {
  const TypeTemplate(this.template);

  final String template;
}
